---
title: 'Rust를 좋아하는 이유(2)'
date: 2023-10-01T12:00:00Z
layout: PostSimple
tags: ['rust']
draft: false
---

### Rust에서의 배열
Rust에서 배열은 같은 타입의 데이터로 고정된 크기를 가집니다. 그렇기에 Stack에 할당되며 인덱스를 통해 접근합니다.  
동적인 크기를 가져야 하는 경우, Rust에서 제공하는 표준 라이브러리인 백터 타입을 사용하면 됩니다.  

```rust
let arr = [1, 2, 3, 4, 5];
```

### 접근하기
대부분의 프로그래밍 언어에서는 배열에 잘못된 인덱스 값으로 접근 할 때 문제가 발생합니다.  
Rust는 애초에 언어 레벨에서 배열의 길이보다 큰 인덱스로 접근 할 경우에 컴파일 에러를 발생 시킵니다.  
혹은 예측 할 수 없는 값이 배열이 인덱스로 사용 된다면 예외처리를 통해서 에러를 해결 할 수 있습니다.

```rust
use rand::Rng;

fn generate_random_usize() -> usize {
    let mut rng = rand::thread_rng();
    rng.gen()
}

fn main() {
    let ran_num = generate_random_usize();
    let arr = [1, 2, 3, 4];
    println!("{}", arr[ran_num]);
}

// 컴파일 결과
   Compiling playground v0.0.1 (/playground)
    Finished dev [unoptimized + debuginfo] target(s) in 0.74s
     Running `target/debug/playground`
thread 'main' panicked at 'index out of bounds: the len is 4 but the index is 15175716449542268142', src/main.rs:11:20
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
```

위처럼 랜덤의 정수를 반환 할 때에 컴파일 타임에 검사를 통해 배열의 크기를 벗어나면 오류를 발생 시킵니다.  
만약 API와 같은 예측 할 수 없는 데이터를 이용 할 때에는 검사를 통해 확인해야 합니다.

```rust
use rand::Rng;

fn generate_random_usize() -> usize {
    let mut rng = rand::thread_rng();
    rng.gen()
}

fn main() {
    let ran_num = generate_random_usize();
    let arr = [1, 2, 3, 4];
    if arr.len() < ran_num {
        println!("Error");
    } else {
        println!("{}", arr[ran_num]);   
    }
}
```